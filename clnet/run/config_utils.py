from batchgenerators.utilities.file_and_folder_operations import *
from clnet.paths import network_training_output_dir


def print_with_rank(*args, rank):
    if rank == 0:
        print(*args)


def get_configuration_from_output_folder(folder):
    # split off network_training_output_dir
    folder = folder[len(network_training_output_dir):]
    if folder.startswith("/"):
        folder = folder[1:]

    configuration, task, trainer_and_plans_identifier = folder.split("/")
    trainer, plans_identifier = trainer_and_plans_identifier.split("__")
    return configuration, task, trainer, plans_identifier


def load_plans_file(self):
    """
    This is what actually configures the entire experiment. The plans file is generated by experiment planning
    :return:
    """

    def convert_keys_to_int(d: dict):
        new_dict = {}
        for k, v in d.items():
            try:
                new_key = int(k)
            except ValueError:
                new_key = k
            if type(v) == dict:
                v = convert_keys_to_int(v)
            new_dict[new_key] = v
        return new_dict

    format = self.plans_file.split('.')[-1]
    if format == 'pkl':
        self.plans = load_pickle(self.plans_file)
    elif format == 'json':
        with open(self.plans_file, 'r') as f:
            self.plans = convert_keys_to_int(json.load(f))
    else:
        raise RuntimeError('Loading plan file format {} not supported!'.format(format))


def dict_duplicate_check(dict_to_check):
    tasks = []
    need_to_be_delete = []
    for task in dict_to_check.keys():
        current_task = dict_to_check[task]["task"]
        if current_task not in tasks:
            tasks.append(current_task)
        else:
            print("Warning: Duplicated tasks for processing. Deleting task -- '%s'" % task)
            need_to_be_delete.append(task)
    for task in need_to_be_delete:
        del dict_to_check[task]
    return dict_to_check


def convert_keys_to_int(d: dict):
    new_dict = {}
    for k, v in d.items():
        try:
            new_key = int(k)
        except ValueError:
            new_key = k
        if type(v) == dict:
            v = convert_keys_to_int(v)
        new_dict[new_key] = v
    return new_dict